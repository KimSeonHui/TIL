# Dynamic Programming  동적 계획법
**하나의 문제를 한 번만 풀도록 하는 알고리즘**
- 큰 문제를 작은 문제로 나눠서 풀 때
- 같은 문제를 풀 때 답이 동일해야 때 = 작은 문제에서 푼 답은 큰 문제에서도 항상 답이 동일할 때

<br />

> 📌 **logic**     
> 같은 문제를 풀 때 답이 동일하기 때문에 **한 번 문제를 풀어 구한 답을 어딘가에 메모(저장)**
> - 이전에 계산한 문제의 답이 필요한 경우 이전에 저장했던 답을 가져와서 사용
> - 저장해 놓은 값을 사용하기 때문에 반복을 줄여 하나의 문제를 한 번만 풀 수 있음

<br />

### 대표적인 문제 - 피보나치 수열
특정 값을 계산할 때 이전 값과 두번째 전 값의 합을 구해야 함.
> **피보나치 수열 점화식** : F\[i] = F\[i - 1] + F\[i - 2]

![image](https://user-images.githubusercontent.com/44824456/168255859-bfaba949-d3e8-4fbc-bb51-8114d8909ade.png)     
위 식에 따라 1,1,2,3,5,8 ... 으로 진행되기 때문에 
- 특정 위치의 값이 항상 동일 
- 다음 피보나치 수열(큰 문제)을 찾을 때 이전 값(작은 문제)이 필요 
    - ex) F\[5] = F\[3] + F\[4]
    - F\[3] = F\[1] + F\[2]
    - F\[4] = F\[2] + F\[3]
    - 현재 값을 계산하는데 이전 값이 필요한 경우 다시 계산할 필요없이 저장한 값을 가져와서 사용

<br />

### 다른 문제들
- **leet code**
   - [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/)

<br />

> 📌 **Divide and Conquer(분할 정복)과 다른 점?**       
> 분할 정복 알고리즘도 동적 계획법과 마찬가지로 큰 문제를 작은 문제로 쪼개서 푸는 방법!    
> 하지만 작은 문제로 쪼갰을 때 이미 계산한 문제를 다시 풀어야 하는 경우
> - **분할 정복** : 계산했던 문제를 다시 계산 ➡ 연산⬆
> - **동적 계획법** : 계산했던 문제의 답이 저장되어 있어 계산 없이 문제 해결 가능

<br />




-----
## 참고
- [동적 프로그래밍이란?](https://galid1.tistory.com/507)
- [다이나믹 프로그래밍](https://blog.naver.com/ndb796/221233570962)
